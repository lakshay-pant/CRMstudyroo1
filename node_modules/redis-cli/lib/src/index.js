"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const yargs_1 = require("yargs");
const url_1 = require("url");
const redis_1 = require("./redis");
const package_json_1 = require("../package.json");
const executor_1 = require("./executor");
const colors_1 = require("colors");
const modes = ['redis'];
const cli = yargs_1.version(package_json_1.version)
    .usage("$0 [OPTIONS] [cmd [arg [arg ...]]]")
    .options({
    "h": {
        alias: "host",
        default: "127.0.0.1",
        describe: 'Server hostname (default: 127.0.0.1).',
        type: 'string'
    },
    "p": {
        alias: "port",
        default: 6379,
        describe: "Server port (default: 6379).",
        type: 'number',
    },
    "s": {
        alias: "socket",
        describe: "Server socket (overrides hostname and port).",
        type: 'string'
    },
    "a": {
        alias: "auth",
        describe: "Server password.",
        type: 'string'
    },
    "u": {
        alias: "uri",
        describe: "Server URI.",
        type: 'string'
    },
    "m": {
        alias: "mode",
        describe: "Server Type, only redis available now.",
        choices: modes,
        default: modes[0]
    },
    "c": {
        alias: "cluster",
        describe: "Enable cluster mode (follow -ASK and -MOVED redirections).",
        boolean: true,
        default: false
    }
}).argv;
const mode = cli.m;
const cluster = cli.c;
if (mode.toLowerCase() == 'redis') {
    let redisClient;
    if (cli.s !== undefined) {
        redisClient = new redis_1.GUIRedisClient({ host: cli.s, cluster });
    }
    else if (cli.u !== undefined) {
        let uri = new url_1.URL(cli.u);
        redisClient = new redis_1.GUIRedisClient({ host: uri.hostname, port: parseInt(uri.port), auth: uri.password, cluster });
    }
    else {
        redisClient = new redis_1.GUIRedisClient({ host: cli.h, port: cli.p, auth: cli.a, cluster });
    }
    if (cli._ && cli._.length > 0) {
        const callback = (result) => {
            if (result._kind == 'Left') {
                if (result.left instanceof executor_1.RequestEnd) {
                    redisClient.shutdown();
                }
                else if (result.left instanceof executor_1.RedirectError) {
                    if (cluster) {
                        let endpoint = result.left.hostAndPort;
                        let key = result.left.key;
                        let newClient = redisClient.getOrCreateClient(key, endpoint);
                        redisClient.next = colors_1.yellow(result.left.message);
                        redisClient.execute(result.left.commands, callback, newClient);
                    }
                    else {
                        redisClient.next = colors_1.red(`MOVED slot=${result.left.slot} node=${result.left.hostAndPort}`);
                    }
                }
                else {
                    redisClient.next = colors_1.red(result.left.message);
                }
            }
            else {
                let resp = result.right;
                if (Array.isArray(resp)) {
                    for (let item of resp) {
                        redisClient.next = colors_1.green(item);
                    }
                }
                else {
                    redisClient.next = colors_1.green(resp);
                }
            }
        };
        redisClient.execute(cli._, callback).then(() => {
            redisClient.shutdown();
        });
    }
    else {
        redisClient.attachEvent();
    }
}
else {
    console.log("Not Support %s Now!", mode);
}
